<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Hunting Buffer Safety Tool</title>    <script src="https://cdn.tailwindcss.com"></script>    <!-- Leaflet for Mapping -->    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>    <!-- Turf.js for Geospatial Analysis (Buffering & Union) -->    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>    <!-- Shpjs to parse zipped shapefiles -->    <script src="https://unpkg.com/shpjs@4.0.4/dist/shp.js"></script>    <!-- Dom-to-image for JPG export -->    <script src="https://cdnjs.cloudflare.com/ajax/libs/dom-to-image/2.6.0/dom-to-image.min.js"></script>    <style>        #map { height: 600px; width: 100%; border-radius: 0.5rem; }        .leaflet-container { background: #1a1a1a; cursor: crosshair; }        .loading-overlay {            display: none;            position: absolute;            inset: 0;            background: rgba(0,0,0,0.85);            z-index: 1000;            justify-content: center;            align-items: center;            flex-direction: column;            color: white;            text-align: center;            padding: 2rem;        }        .mode-active {            border: 2px solid #f97316 !important;            background-color: #431407 !important;        }        /* Legend Styling for Map Integration */        .map-legend {            background: rgba(15, 23, 42, 0.95);            padding: 12px;            border-radius: 8px;            border: 1px solid rgba(51, 65, 85, 1);            color: white;            font-family: ui-sans-serif, system-ui, sans-serif;            font-size: 11px;            line-height: 1.4;            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.5);            cursor: move; /* Draggable */            pointer-events: auto !important;            min-width: 160px;        }        .legend-item { display: flex; align-items: center; margin-bottom: 5px; gap: 10px; }        .legend-swatch { width: 16px; height: 16px; flex-shrink: 0; }    </style></head><body class="bg-slate-900 text-slate-100 min-h-screen font-sans">    <div class="max-w-6xl mx-auto p-4 md:p-8">        <header class="mb-8 border-b border-slate-700 pb-4">            <h1 class="text-3xl font-bold text-orange-500">Hunting Safety Buffer Tool</h1>            <p class="text-slate-400 mt-2">Upload property boundaries and generate merged safety zones with trails and structures.</p>        </header>        <div class="grid grid-cols-1 lg:grid-cols-4 gap-6">            <!-- Sidebar Controls -->            <div class="lg:col-span-1 space-y-6">                <section class="bg-slate-800 p-4 rounded-xl shadow-lg border border-slate-700">                    <h2 class="text-sm font-semibold uppercase tracking-wider text-slate-400 mb-4">1. Property Boundary</h2>                    <div class="space-y-3">                        <label class="block">                            <span class="sr-only">Choose Zip Shapefile</span>                            <input type="file" id="shpUpload" accept=".zip"                                 class="block w-full text-sm text-slate-400                                file:mr-4 file:py-2 file:px-4                                file:rounded-full file:border-0                                file:text-sm file:font-semibold                                file:bg-orange-600 file:text-white                                hover:file:bg-orange-700 cursor-pointer">                        </label>                        <div class="bg-slate-900/50 p-3 rounded border border-slate-700 text-[10px] text-slate-400">                            <p class="font-bold mb-1">Requirement:</p>                            <p>Zip must contain .shp, .dbf, .shx, and preferably .prj (WGS84).</p>                        </div>                    </div>                </section>                <section class="bg-slate-800 p-4 rounded-xl shadow-lg border border-slate-700">                    <h2 class="text-sm font-semibold uppercase tracking-wider text-slate-400 mb-4">2. Map Data</h2>                    <div class="space-y-3">                        <button id="fetchBuildings" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-lg transition text-sm">                            Fetch USA Structures                        </button>                                                <button id="fetchTrails" class="w-full bg-emerald-600 hover:bg-emerald-700 text-white font-medium py-2 px-4 rounded-lg transition text-sm">                            Fetch Trails                        </button>                                                <div class="border-t border-slate-700 pt-3">                            <button id="toggleManualMode" class="w-full bg-slate-700 hover:bg-slate-600 text-white font-medium py-2 px-4 rounded-lg transition text-sm flex items-center justify-center gap-2">                                <span id="manualIcon">üìç</span> Add Manual Points                            </button>                            <p class="text-[10px] text-slate-500 mt-2 italic text-center">Drag the Key on the map to avoid overlaps.</p>                        </div>                        <button id="clearManual" class="w-full text-red-400 hover:text-red-300 text-[10px] underline uppercase tracking-widest font-bold">                            Clear Manual Points                        </button>                    </div>                </section>                <section class="bg-slate-800 p-4 rounded-xl shadow-lg border border-slate-700">                    <h2 class="text-sm font-semibold uppercase tracking-wider text-slate-400 mb-4">3. Safety Zones</h2>                    <div class="space-y-4">                        <div>                            <label class="text-xs text-slate-400">Buffer Distance (Feet)</label>                            <input type="number" id="bufferDist" value="450" class="w-full bg-slate-700 border border-slate-600 rounded p-2 text-white">                        </div>                        <button id="calcBuffer" class="w-full bg-orange-600 hover:bg-orange-700 text-white font-medium py-2 px-4 rounded-lg transition">                            Generate & Merge Zones                        </button>                    </div>                </section>                <section class="bg-slate-800 p-4 rounded-xl shadow-lg border border-slate-700">                    <h2 class="text-sm font-semibold uppercase tracking-wider text-slate-400 mb-4">4. Exports</h2>                    <div class="grid grid-cols-2 gap-2">                        <button id="exportJpg" class="bg-slate-700 hover:bg-slate-600 text-white text-xs py-2 rounded font-bold">Map (JPG)</button>                        <button id="exportShp" class="bg-slate-700 hover:bg-slate-600 text-white text-xs py-2 rounded">Buffer (GeoJSON)</button>                    </div>                </section>            </div>            <!-- Map Area -->            <div class="lg:col-span-3 relative">                <div id="map-container" class="bg-slate-800 p-2 rounded-xl shadow-2xl border border-slate-700 overflow-hidden">                    <div id="map"></div>                </div>                                <div id="loading" class="loading-overlay rounded-xl">                    <div class="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-orange-500 mb-4"></div>                    <p id="loadingMsg" class="font-medium text-lg">Processing spatial data...</p>                    <p id="loadingHint" class="text-sm text-slate-400 mt-2 max-w-sm"></p>                </div>                <div class="mt-4 text-xs text-slate-500 flex justify-between">                    <span>Note: Map legend is draggable. Move it before exporting.</span>                    <span>Standard Buffer: 450ft</span>                </div>            </div>        </div>    </div>    <script>        let map, propertyLayer, buildingLayer, trailLayer, bufferLayer, manualPointsLayer, legendControl;        let propertyData = null, searchAreaData = null, buildingsData = null, trailsData = null, bufferData = null;        let manualPointsData = { type: "FeatureCollection", features: [] };        let isManualMode = false;        let isExporting = false;         const USA_STRUCTURES_URL = "https://services2.arcgis.com/FiaPA4ga0iQKduv3/arcgis/rest/services/USA_Structures_View/FeatureServer/0";        const TRAILS_URL = "https://services.arcgis.com/M0RcaZONLNmkvwdY/arcgis/rest/services/trailssep2015/FeatureServer/0";        function initMap() {            try {                map = L.map('map', {                    attributionControl: false,                    preferCanvas: true                }).setView([40, -95], 4);                L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {                    maxZoom: 19                }).addTo(map);                manualPointsLayer = L.layerGroup().addTo(map);                addLegend();                map.on('click', (e) => {                    if (!isManualMode || isExporting) return;                                        const point = turf.point([e.latlng.lng, e.latlng.lat]);                    manualPointsData.features.push(point);                                        L.circleMarker(e.latlng, {                        radius: 6,                        fillColor: "#eab308",                         color: "#fff",                        weight: 2,                        opacity: 1,                        fillOpacity: 1                    }).addTo(manualPointsLayer);                                        showMessage("Manual structure added.");                });            } catch (e) {                console.error("Map initialization failed:", e);            }        }        function addLegend() {            legendControl = L.control({ position: 'bottomright' });            legendControl.onAdd = function() {                const div = L.DomUtil.create('div', 'map-legend');                div.innerHTML = `                    <div style="font-weight:bold; margin-bottom: 8px; border-bottom: 1px solid #444; padding-bottom: 4px; display:flex; justify-content: space-between;">                        <span>MAP KEY</span>                        <span id="legend-drag-hint" style="font-size: 8px; opacity: 0.5;">(DRAG TO MOVE)</span>                    </div>                    <div class="legend-item">                        <div class="legend-swatch" style="border: 2px solid #f97316; background: rgba(249, 115, 22, 0.1);"></div>                        <span>Property Boundary</span>                    </div>                    <div class="legend-item">                        <div class="legend-swatch" style="border: 1px solid #dc2626; background: rgba(220, 38, 38, 0.45); border-radius: 50%;"></div>                        <span>Hunting Safety Buffer</span>                    </div>                    <div class="legend-item">                        <div class="legend-swatch" style="background: #3b82f6; opacity: 0.7; border-radius: 2px;"></div>                        <span>GIS Building</span>                    </div>                    <div class="legend-item">                        <div class="legend-swatch" style="background: #eab308; border: 2px solid white; border-radius: 50%;"></div>                        <span>Manual Structure</span>                    </div>                    <div class="legend-item">                        <div class="legend-swatch" style="border-top: 2px dashed #22c55e; height: 0; margin-top: 7px;"></div>                        <span>Trail</span>                    </div>                `;                                setTimeout(() => {                    const draggable = new L.Draggable(div);                    draggable.enable();                }, 0);                return div;            };            legendControl.addTo(map);        }        function toggleLoading(show, msg = "Processing...", hint = "") {            const loader = document.getElementById('loading');            document.getElementById('loadingMsg').innerText = msg;            document.getElementById('loadingHint').innerText = hint;            loader.style.display = show ? 'flex' : 'none';        }        document.getElementById('toggleManualMode').addEventListener('click', () => {            isManualMode = !isManualMode;            const btn = document.getElementById('toggleManualMode');            if (isManualMode) {                btn.classList.add('mode-active');                btn.innerHTML = "<span>üõë</span> Stop Adding Points";                showMessage("Manual Mode ON: Click map to place buildings.");            } else {                btn.classList.remove('mode-active');                btn.innerHTML = "<span>üìç</span> Add Manual Points";                showMessage("Manual Mode OFF.");            }        });        document.getElementById('clearManual').addEventListener('click', () => {            manualPointsData.features = [];            manualPointsLayer.clearLayers();            showMessage("All manual points cleared.");        });        document.getElementById('shpUpload').addEventListener('change', async (e) => {            const file = e.target.files[0];            if (!file) return;            toggleLoading(true, "Parsing ZIP Shapefile...");                        try {                const arrayBuffer = await file.arrayBuffer();                let geojson = await shp(arrayBuffer);                                if (Array.isArray(geojson)) {                    geojson = {                        type: "FeatureCollection",                        features: geojson.flatMap(layer => layer.features)                    };                }                if (propertyLayer) map.removeLayer(propertyLayer);                if (buildingLayer) map.removeLayer(buildingLayer);                if (trailLayer) map.removeLayer(trailLayer);                if (bufferLayer) map.removeLayer(bufferLayer);                                propertyData = geojson;                                const searchDistMiles = 500 / 5280;                searchAreaData = turf.buffer(propertyData, searchDistMiles, { units: 'miles' });                propertyLayer = L.geoJSON(propertyData, {                    style: { color: "#f97316", weight: 3, fillOpacity: 0.1 }                }).addTo(map);                map.fitBounds(propertyLayer.getBounds().pad(0.1));                showMessage("Property loaded successfully.");            } catch (err) {                showMessage("Error loading Shapefile.");            }            toggleLoading(false);            e.target.value = "";        });        document.getElementById('fetchBuildings').addEventListener('click', async () => {            if (!propertyData) { showMessage("Please upload a property boundary first."); return; }            toggleLoading(true, "Searching USA Structures...");                        try {                const searchBounds = L.geoJSON(searchAreaData).getBounds();                const params = new URLSearchParams({                    f: 'geojson',                    geometry: `${searchBounds.getWest()},${searchBounds.getSouth()},${searchBounds.getEast()},${searchBounds.getNorth()}`,                    geometryType: 'esriGeometryEnvelope',                    spatialRel: 'esriSpatialRelIntersects',                    outFields: 'OBJECTID,OCC_CLS',                    inSR: '4326', outSR: '4326'                });                const response = await fetch(`${USA_STRUCTURES_URL}/query?${params.toString()}`);                const rawData = await response.json();                const filterPoly = searchAreaData.features ? searchAreaData.features[0] : searchAreaData;                const filteredFeatures = (rawData.features || []).filter(f => {                    try { return turf.booleanIntersects(f, filterPoly); } catch (e) { return false; }                });                buildingsData = { type: "FeatureCollection", features: filteredFeatures };                if (buildingLayer) map.removeLayer(buildingLayer);                buildingLayer = L.geoJSON(buildingsData, {                    style: { color: "#3b82f6", weight: 1, fillOpacity: 0.6 },                    onEachFeature: (f, l) => l.bindPopup(`<b>${f.properties.OCC_CLS || "Structure"}</b>`)                }).addTo(map);                showMessage(`Found ${buildingsData.features.length} GIS building footprints.`);            } catch (err) {                showMessage("Failed to fetch GIS data.");            }            toggleLoading(false);        });        document.getElementById('fetchTrails').addEventListener('click', async (e) => {            if (!propertyData) { showMessage("Please upload a property boundary first."); return; }            toggleLoading(true, "Fetching Trails...");                        try {                const searchBounds = L.geoJSON(searchAreaData).getBounds();                const params = new URLSearchParams({                    f: 'geojson',                    geometry: `${searchBounds.getWest()},${searchBounds.getSouth()},${searchBounds.getEast()},${searchBounds.getNorth()}`,                    geometryType: 'esriGeometryEnvelope',                    spatialRel: 'esriSpatialRelIntersects',                    outFields: '*',                    inSR: '4326', outSR: '4326'                });                const response = await fetch(`${TRAILS_URL}/query?${params.toString()}`);                const rawData = await response.json();                const filterPoly = searchAreaData.features ? searchAreaData.features[0] : searchAreaData;                const filteredFeatures = (rawData.features || []).filter(f => {                    try { return turf.booleanIntersects(f, filterPoly); } catch (e) { return false; }                });                trailsData = { type: "FeatureCollection", features: filteredFeatures };                if (trailLayer) map.removeLayer(trailLayer);                trailLayer = L.geoJSON(trailsData, {                    style: {                         color: "#22c55e",                         weight: 2.5,                         dashArray: '5, 8',                        opacity: 0.9                    }                }).addTo(map);                showMessage(`Loaded ${trailsData.features.length} trails.`);            } catch (err) {                showMessage("Failed to fetch trails.");            }            toggleLoading(false);        });        document.getElementById('calcBuffer').addEventListener('click', () => {            const hasGis = buildingsData && buildingsData.features.length > 0;            const hasManual = manualPointsData && manualPointsData.features.length > 0;            if (!hasGis && !hasManual) {                 showMessage("Fetch structures or add manual points first.");                 return;             }                        toggleLoading(true, "Generating & Merging buffers...");                        try {                const distFeet = parseFloat(document.getElementById('bufferDist').value) || 450;                const distMiles = distFeet / 5280;                                const allStructures = [                    ...(hasGis ? buildingsData.features : []),                    ...(hasManual ? manualPointsData.features : [])                ];                const buffers = allStructures.map(f => turf.buffer(f, distMiles, { units: 'miles' }));                let mergedBuffer = buffers[0];                for (let i = 1; i < buffers.length; i++) {                    mergedBuffer = turf.union(mergedBuffer, buffers[i]);                }                bufferData = {                    type: "FeatureCollection",                    features: [mergedBuffer]                };                if (bufferLayer) map.removeLayer(bufferLayer);                                bufferLayer = L.geoJSON(bufferData, {                    style: { color: "#dc2626", weight: 1.5, fillColor: "#dc2626", fillOpacity: 0.35 }                }).addTo(map);                showMessage(`${distFeet}ft safety zones merged.`);            } catch (err) {                showMessage("Error calculating buffers.");            }            toggleLoading(false);        });        document.getElementById('exportJpg').addEventListener('click', async () => {            if (!propertyLayer) { showMessage("Upload a property before exporting."); return; }                        isExporting = true;            toggleLoading(true, "Formatting map for export...", "Locking view to parcel outline...");            const originalCenter = map.getCenter();            const originalZoom = map.getZoom();            try {                const parcelBounds = propertyLayer.getBounds();                map.fitBounds(parcelBounds.pad(0.08), { animate: false });                                await new Promise(resolve => setTimeout(resolve, 3000));                const mapNode = document.getElementById('map');                const uiControls = document.querySelectorAll('.leaflet-control-zoom, .leaflet-control-attribution');                uiControls.forEach(c => c.style.display = 'none');                                const dragHint = document.getElementById('legend-drag-hint');                if (dragHint) dragHint.style.display = 'none';                const dataUrl = await domtoimage.toJpeg(mapNode, {                     quality: 0.95,                     bgcolor: '#1a1a1a'                 });                                const link = document.createElement('a');                link.download = `Hunting_Safety_Map_${Date.now()}.jpg`;                link.href = dataUrl;                link.click();                uiControls.forEach(c => c.style.display = 'block');                if (dragHint) dragHint.style.display = 'inline';                                showMessage("Map exported successfully.");            } catch (err) {                showMessage("Failed to export image.");            } finally {                map.setView(originalCenter, originalZoom, { animate: false });                isExporting = false;                toggleLoading(false);            }        });        document.getElementById('exportShp').addEventListener('click', () => {            if (!bufferData) { showMessage("Please generate buffers first."); return; }            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(bufferData));            const dl = document.createElement('a');            dl.setAttribute("href", dataStr);            dl.setAttribute("download", "hunting_safety_buffers.geojson");            dl.click();        });        function showMessage(msg, duration = 4000) {            const div = document.createElement('div');            div.className = "fixed bottom-8 left-1/2 -translate-x-1/2 bg-slate-800 border border-orange-500 text-white px-6 py-4 rounded-lg shadow-2xl z-[2000] text-sm font-medium max-w-md text-center";            div.innerText = msg;            document.body.appendChild(div);            setTimeout(() => {                div.classList.add('opacity-0', 'transition-opacity', 'duration-500');                setTimeout(() => div.remove(), 500);            }, duration);        }        window.onload = initMap;    </script></body></html>